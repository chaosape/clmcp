
todo   
    - checksumming / checking magic numbers


verification
===

- SAW can't handle the generic functions yet efficiently, since this branches on raw data.

- for nested structs, see nested.c in saw examples 



- SAW can't do floats
    - verify float <-> int32 / double <-> int64 separately


- SAW has a hard time with branching on raw data. maybe moving to a Hoare-style approach would make this easier?

meeting
===

-- connection between properties about packsize & inputs to packing & unpacking

-- proving things about invalid messages: error handling & formal specification of invalid behavior
-- parallel in C: look how invalid messages in uxas are handled

-- in saw: mutually recursive things are hard to symbolic simulate

-- proving properties about unpack without any restrictions on the data

"what do i say about data i do not have control over"

-- length field may be malicious

mindset: any data from network: i need to be very defensive about it
check for any pathological behavior

to answer
===

specific goals?

\forall MDMs, \forall struct S in MDM, \forall v : S, deserialize \circ serialize (v) = v
Gen(MDM): iterate through structs S in MDM:
Gen(MDM)(S): symbolically prove that for all v in S, deserialize \circ serialize (v) == v

Things we want
-- portability
-- Extensibility for using crypto/whatever

-- safe conversion functions: uxas uses unsafe casts to convert between 


-- concrete security concerns: maximum size? as an option? if unbounded size, streaming / checking for well-formedness along the way?
-- low memory modes?
-- using a hash function for the checksum?

-- branching on messagetype as part of the serialization library, instead of ad-hoc
-- other stuff that can be ported into the library

-- rust in saw?


mattermost saw
===

rust move semantics
floating point numbers

steven about concrete security


programming tasks
===

C++ interface
other interfaces if needed (java? python?) 


what adams doing
===


